## 关于 Java
### Java 语言的特点
1. 面向对象：支持对象的封装、继承、多态。
2. <span style="background:#b1ffff">跨平台</span>：利用 JVM（C++语言模拟的一个虚拟的计算机）进行跨平台实现。
3. 安全性：提供了一系列的安全措施来保护程序不受恶意攻击和病毒侵害。
4. 高性能：采用一系列优化措施来提高程序的执行速度和内存使用效率。
5. 多线程支持：提供了一系列的线程控制机制，使得程序可以更好地利用计算机的多核处理能力。
6. <span style="background:#b1ffff">自动垃圾回收机制</span>：防止内存泄漏，垃圾自动回收，但会影响处理速度。
### Java 中的三种注释方式
1. 单行注释 
2. 多行注释 
3. Javadoc 注释（可生成 Java 程序的帮助文档）
## Java 基础语法
### 进制
- 前面什么没有，则是十进制
- 以 0 开头为八进制
- 以 0b 开头为二进制
- 以 0x 开头为十六进制
#### 二进制转换为十六进制
- 将二进制数从右往左每四位一组，不足四位则在左侧补 0，得到若尬歌四位二进制。
- 将每一个四位二进制数转换为对应的十六进制数。
#### 十六进制转换为二进制
- 将十六进制中的每个数字转换成 4 个二进制位
### 原码反码补码
- 原码反码补码
	1. 原码反码补码是计算机二进制的三种表示形式。
	2. 计算机在底层都是采用二进制补码形式表示的。
	3. 二进制位最高位称为符号位，0 为正数，1 为负数。
- 正数的原码反码补码
	1. 正数的原码反码补码都是相同的。
	2. 例如 127 的原码反码补码都为 0111 1111
- 负数的原码反码补码
	1. 负数的原码运算规则：将绝对值转换为二进制后，最高位改为 1。
	2. 例如 -5 的原码：1000 0101
	3. -5 的反码：1111 1010（原则是：以原码作为参考，符号位不变，其他位相反。）
	4. -5 的补码：1111 1011（原则是：以反码作为参考。符号位不变，加 1）
- 负数补码怎么得到原码
	- 将负数的补码形式除符号位外的所有位按位取反，再加 1 即可得到原码。
### 计算机底层为什么采用补码
- 可以简化电路的设计：采用补码形式可以将加减法运算转化为相同的操作，从而简化电路设计。
- 解决了 0 的正负问题：在原码中，0 有两个表示，+0 和 -0，这样会导致计算结果不唯一，而在补码中，0 只有一种表示，即全 0，可以避免这个问题。
- 解决了负数溢出问题：在原码中，负数的表示范围比正数少 1，这样在进行减法运算时容易出现负数溢出的情况。而在补码中。负数的表示范围与正数相同，可以避免负数溢出的问题。
- 方便计算机进行运算：补码形式可以方便计算机进行加减法运算，而且可以使用相同的电路进行运算，从而提高了计算机的运算效率。
### 数据类型
#### 整型
- Java 中任何一个“整数型字面量”都会默认被当做 int 类型来处理。
- Java 中运行小容器的数据直接赋值给大容器的变量。
- Byte < short < int < long < float < double
#### 字符型
##### 字符编码
- 字符编码是人为规定的文字与二进制之间的转换关系。
##### 出现乱码原因
- 出现乱码是因为编码和解码时用的不是同一套码表。
### 运算符
#### 按位运算符
- 任何位运算符，操作的都是补码。
##### 左移 <<
- 它能够将一个二进制数的所有位向左移动指定的位数。
- 将二进制数左移 n 位，相当于将数值<span style="background:#fdbfff">乘以</span> 2 的 n 次方。
- 左移运算符不会改变操作数的符号。
- 左移运算符会对溢出进行截断。
##### 右移 >>
- 它能够将一个二进制数的所有位向右移动指定的位数。
- 将二机制数右移 n 位，相当于将数值<span style="background:#fdbfff">除以</span> 2 的 n 次方。
- 右移运算符对正数、负数和零的处理方式不同。
	- 对于正数，符号位不变，右移时左补 0。
	- 对于负数，符号位不变，右移时左补 1。
	- 对于零，右移运算符操作后结果仍为零。
- 右移运算符会对溢出进行截断。
##### 无符号右移 >>>
- 将二进制数右移 n 位，相当于将数值<span style="background:#fdbfff">除以</span> 2 的 n 次方，并将最高位填充为 0。
- 任意一个数字经过无符号右移之后，最终结果一定是非负数（0 或正整数）
#### 扩展赋值运算符
- 对于扩展运算符来说，永远都不会改变运算结果类型。哪怕精度损失。
### 方法
#### 方法执行时的内存变化：
1. 方法只定义不调用是不会分配内存的。（从 Java 8 开始，方法的字节码指令存储在元空间 metaspace 当中。元空间使用的是本地内存。）
2. 方法调用的瞬间，会在栈内存当中分配活动场所，此时发生压栈动作。这个方法的空间被称为栈帧。
3. 栈帧主要包括：局部变量表，操作数栈等。
4. 方法执行结束时，该栈帧弹栈，方法内存空间释放。
### Package 语句
#### 定义了包之后，怎么带包编译
- 语法：javac -d 生成目录 源文件路径
#### Package 命名规范：
- 公司域名倒序 + 项目名 + 模块名 + 功能名
## 面向对象
### 面向对象的概述
#### 软件开发方法：面向过程和面向对象
- 面向过程：关注点在实现功能的步骤上
	- PO：Procedure Oriented。
	- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用。
	- 对于简单的流程是适合使用面向过程的方式进行的。复杂的流程不适合使用面向过程的开发方式。
- 面向对象：关注点在实现功能需要哪些对象对象的参与。
	- OO：Object Oriented。包括 OOA、OOD、OOP。OOA：Object Oriented Analysis 面向对象分析。OOD：Object Oriented Design 面向对象设计。OOP：Object Oriented Programming 面向对象编程。
	- 人类是采用面向对象的方式去认知世界的。所以采用面向对象的思想更加容易处理复杂的问题。
	- 面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统。
	- 面向对象开发方式耦合度低，扩展能力强。
#### 面向对象三大特征
1. 封装（Encapsulation）
2. 继承（Inheritance）
3. 多态（Polymorphism）
### JVM 内存分析
1. 元空间（Metaspace）中存储的是类的元信息，字节码等。元空间是 Java 8 之后引入的。元空间可以看作是 JVM 规范中方法区的实现。方法区是：JVM 规范中的叫法。元空间是：对方法区的实现。
2. 在 Java 8 之前，方法区的具体实现叫做：永久代。在 Java 8 之后，永久代被丢弃了。永久代是对方法区的实现。
3. 方法区是规范：永久代是实现（<=Java 7）。元空间也是实现（>=Java 8）。
4. 所有使用运算符 new 的对象，都存在堆内存当中。
5. 虚拟机栈 VM Stack 中存储：栈帧。当方法被调用的时候，会给该方法分配空间，在 VM Stack 中压栈，压入一个栈帧。这个栈帧就是该方法的活动空间。每个栈帧中有：局部变量表，操作数栈等。
6. 局部变量存储在虚拟机栈的栈帧当中。
7. 实例变量存储在 JVM 堆内存的 Java 对象内部。
8. 对象和引用的区别
	- 对象：在堆内存当中，new 出来的。
	- 引用：是一个保存了对象内存地址的变量。
	- 在 Java 中，程序员是不能直接操作堆内存的。需要借助引用来访问堆内存。
9. JVM 中有 GC 机制，垃圾回收机制，Java 是自动垃圾回收。自动垃圾回收主要针对的是堆区。
	- 如果没有任何引用指向该对象，该对象最终会被当做垃圾，被 GC 回收。
### This 关键字
- This 关键字用来在区分局部变量和实例变量时不能省略。
### 构造方法执行原理
- 构造方法执行包括两个重要的阶段：
	- 第一阶段：对象的创建
	- 第二阶段：对象的初始化
- 对象在什么时候创建的？
	- New 的时候，会直接在堆内存中开辟空间，然后给所有属性赋默认值，完成对象的创建。（这个过程是在构造方法体执行之前就完成了。）
- 对象初始化在什么时候完成的？
	- 构造方法体开始执行，标志着开始进行对象初始化。构造方法体执行完毕，表示对象初始化完毕。
### JVM 体系结构
#### JVM 规范中的运行时数据区
1. The pc Register（程序计数器）：是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址。
2. Java Virtual Machine Stacks（Java 虚拟机栈）：Java 虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
3. Heap（堆）：是 Java 虚拟机所管理的最大的一块内存。堆内存用于存放 Java 对象的实例以及数组。堆是垃圾收集器手机垃圾的主要区域。
4. Method Area（方法区）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据。
5. Run-Time Constant Pool （运行时常量池）：是方法区的一部分，用于存储编译期生成的各种字面量与符号引用。
6. Native Method Stacks（本地方法栈）：在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机十分相似。
### 多态
- 因为编译阶段是一种形态，运行的时候是另一种形态。因此得名：多态。
- 能多用多态尽量使用多态。尽量面向抽象编程，不要面向具体编程。
- 面向抽象编程的好处：降低耦合度，提高扩展力。
#### 向下转型
-  instanceof 运算符可以解决 ClassCastException 异常。
	1. instanceof 运算符的结果一定是：true/false
	2. 语法格式：
		- （引用 instanceof 类型）
### 接口
#### 接口与抽象类如何选择
- 抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同：
	- 抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码复用，建议为这几个类提取出来一个父类，在该父类中编写公共代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。
	- 接口主要用于功能的拓展。例如有很多类，一些类需要这个方法，另一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口。不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。
### 关于 main 方法上的 String[] args 作用是什么
1. 作用：接收命令行参数用的。
2. JVM 负责调用 ArrayTest. Main()方法。
## 异常
### 异常的继承结构
- 父类为：Throwable
	- Exception 的所有子类（除 RuntimeException 之外）都是：
		- 编译时异常（所有的编译时异常，要求程序员在编写程序阶段必须对其进行预处理，如果没有预先处理，则编译器会报错。）
		- 检查异常（CheckedException）
		- 受控异常
		- 所有因为外在因素导致的异常都是这种异常
	- RuntimeException
		- 运行时异常（所有运行时异常在程序员编写程序阶段，可以选择处理，也可以选择不处理，随便都是。）
		- 未检查异常（UncheckedException）
		- 非受控异常
		- 所有因为程序员编程导致的异常都是这种异常
	- 无论是编译时异常还是运行时异常，异常的发生都是在运行阶段的。在编译阶段异常是不会发生的。这种异常必须在编译阶段处理，如果不处理，编译器报错，因此叫编译时异常。
### 异常的常用方法
- 获取异常的简单描述信息：
	- exception.getMessage();
	- 获取的 message 是通过构造方法创建异常对象时传递过去的 message。
- 打印异常堆栈信息：
	- exception.printStackTrace();
- 要会看异常的堆栈信息：
	- 异常信息的打印是符合栈数据结构的。
	- 看异常信息主要看最开始的描述信息。看栈顶信息。
## 集合
### Collection
- 所有以<span style="background:#fdbfff">单个方式存储元素</span>的这些集合都继承了 Collection 接口。
- <span style="background:#b1ffff">父类</span>：Iterable：所有 Collection 集合都是可以迭代的都是可以遍历的。
### 集合迭代删除
- 使用集合的删除方法会出现<span style="background:#40a9ff">并发修改异常</span>（fail-fast 机制）
- 使用迭代器的删除方法则不会出现
- 则使用删除时，建议使用迭代器删除，主要为了避免并发修改异常的发生。
## 目前为止，对象克隆的方式：
- 调用 Object 的 clone 方法，默认是浅克隆，需要深克隆的话，就需要重写 clone 方法。
- 可以通过序列化和反序列化完成对象的克隆。
- 也可以通过 ByteArrayInputStream 和 ByteArrayOutputStream 完成深克隆。
## 线程
### 在 Java 语言中，实现线程，有两种方式
####  第一种方式 ：
1. 编写一个类继承 java.lang.Thread
2. 编写 run 方法
3. new 线程对象
4. 调用线程对象的 start 方法来启动线程。
#### 第二种方式：
1. 编写一个类实现 java.lang.Runnable 接口（可运行的接口）
2. 实现接口中的 run 方法
3. new线程对象
4. 调用线程的start方法启动线程
### 线程的生命周期：
1. NEW
	- 新建状态
2. RUNNABLE
	- 可运行状态
	- 细分的话，又可以分为两个子状态
		1. 就绪状态
			- 就绪状态的线程有权利抢夺CPU时间片。
			- 当线程抢夺到CPU时间片之后，开始执行run方法，run方法的开始执行标志着线程进入运行状态。
		2. 运行状态
			- 当线程执行run方法，则标志着线程进入运行状态
			- 在运行过程中，如果CPU时间片用完了。则再次回到就绪状态继续抢夺CPU时间片。
			- 当再次抢到CPU时间片之后，则再次进入run方法，接着上一次的run方法继续向下执行。
			- 直到run方法执行结束，线程进入终止状态。
			- 线程大部分情况下是在运行状态和就绪状态两个状态之间频繁切换。
3. BLOCKED
	- 阻塞状态
	- 遇到锁之后进入阻塞状态（synchronized）
4. WAITING
	- 等待状态
	- 无期限的等待，没有时长限定
5. TIMED_WAITING
	- 超时等待状态
	- 这种等待是有时长限定的
6. TERMINATED
	- 终止状态（死亡状态）
#### 面试的时候，线程的生命周期说几个状态？七个状态：
1. 新建状态
2. 就绪状态
3. 运行状态
4. 超时等待状态
5. 等待状态
6. 阻塞状态
7. 终止状态
### 在Java语言中，线程被分为两大类
- 第一类：用户线程（非守护线程）
- 第二类：守护线程（后台线程）
	1. 在JVM当中，有一个隐藏的守护线程一直在守护着，它就是GC线程。
	2. 守护线程的特点：所有用户线程结束之后，守护线程自动退出/结束。
	3. 如何将一个线程设置为守护线程：t.setDaemon(true);
### JDK中提供的定时任务：
	- java.util.Timer
	- java.util.TimerTask
- 定时器 + 定时任务：可以帮我们在程序中完成：每间隔多久执行一次某段程序。





















